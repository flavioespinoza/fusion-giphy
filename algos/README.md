
# Homework

## Reference Materials

- [Big O Cheat Sheet](https://www.bigocheatsheet.com/)
- [Javascript Algorithms](https://mgechev.github.io/javascript-algorithms/index.html)

## Arrays

[Add one to number](https://leetcode.com/problems/plus-one/) | [My solution](arrays/plus-one.js)

[Wave array](https://www.interviewbit.com/problems/wave-array/) | [My solution](arrays/wave-array.js)

[First missing positive](https://leetcode.com/problems/first-missing-positive/) | [My solution](arrays/first-missing-positive.js)

[Hotel bookings possible](https://www.interviewbit.com/problems/hotel-bookings-possible/) | [My solution](arrays/hotel-bookings-possible.js)

## Linked Lists

[Partition list](https://leetcode.com/problems/partition-list/) | [My solution](linked-list/partition-list.js) | [Times](linked-list/partition-list.jpg)

[Remove duplicates from sorted list](https://leetcode.com/problems/remove-duplicates-from-sorted-list/) | [My solution](linked-list/remove-duplicates-from-sorted-list.js) | [Times](linked-list/remove-duplicates-from-sorted-list.jpg)

[Merge two sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [My solution](linked-list/merge-two-sorted-lists.js) | [Times](linked-list/merge-two-sorted-lists.jpg)

## Patterns

**Sliding window**

[Longest substring without repeating characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | [My solution](patterns/sliding-window/longest-substring-without-repeating-characters.js)

[Longest substring with at most 2 distinct characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/) | [My solution](patterns/sliding-window/longest-substring-with-at-most-two-distinct-characters.js)

[Subarray product less than K](https://leetcode.com/problems/subarray-product-less-than-k/) | [My solution](patterns/sliding-window/subarray-product-less-than-k.js)

**Closing window (2 pointers)**

[3 sum](https://leetcode.com/problems/3sum/) | [My solution](patterns/closing-window/n-sum.js)

[4 sum](https://leetcode.com/problems/4sum/) | [My solution](patterns/closing-window/n-sum.js)

[Trapping rain water](https://leetcode.com/problems/trapping-rain-water) | [My solution](patterns/closing-window/trapping-rain-water.js)

## Maximum Sum Subarray

[Flip](https://www.interviewbit.com/problems/flip/) | [My solution](maximum-sum-subarray/flip.js)


[Max subarray](https://leetcode.com/problems/maximum-subarray/) | [My solution](maximum-sum-subarray/max-subarray.js)

**Sum subarray = k**

[Maximum size subarray sum equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/) | [My solution](maximum-sum-subarray/max-subarray-length.js)

## Monotonic Queues

[Next greater element i](https://leetcode.com/problems/next-greater-element-i/) | [My solution](monotonic-queues/next-greater-element-i.js)

[Largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) | [My solution](monotonic-queues/largest-rectangle-in-histogram.js)

## Bucketing (a.k.a. Counting Sort)

[Top k frequent words](https://leetcode.com/problems/top-k-frequent-words/) | [My solution](bucketing-count-sort/top-k-frequent-words.js)


## Strings & Binary Search

**Problems to get exposed to the topics**:

[Binary search](https://leetcode.com/problems/binary-search/) | [My solution](strings-and-binary-search/binary-search.js)

[Sorted insert position](https://leetcode.com/problems/search-insert-position/) | [My solution](strings-and-binary-search/sorted-insert-position.js)

[Search range](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | [My solution](strings-and-binary-search/search-range.js)

[Square root of integer](https://www.interviewbit.com/problems/square-root-of-integer/) | [My solution](strings-and-binary-search/square-root-of-integer.js)

[Is palindrome](https://leetcode.com/problems/valid-palindrome/) | [My solution](strings-and-binary-search/valid-palindrome.js)

[Longest common prefix](https://leetcode.com/problems/longest-common-prefix/) | [My solution](strings-and-binary-search/longest-common-prefix.js)

[Reverse the string](https://www.interviewbit.com/problems/reverse-the-string/) | [My solution](strings-and-binary-search/reverse-the-string.js)

[Roman to integer](https://leetcode.com/problems/roman-to-integer/) | [My solution](strings-and-binary-search/roman-to-integer.js)

[Add binary strings](https://leetcode.com/problems/add-binary/) | [My solution](algos/strings-and-binary-search/add-binary.js)

[Convert zigzag string](https://leetcode.com/problems/zigzag-conversion/) | [My solution](strings-and-binary-search/convert-zigzag-string.js)

### Pattern problems

**Trie**:
[Implement trie prefix tree](https://leetcode.com/problems/implement-trie-prefix-tree/) | [My solution](strings-and-binary-search/implement-trie-prefix-tree.js)

https://www.interviewbit.com/problems/hotel-reviews/

https://www.interviewbit.com/problems/shortest-unique-prefix/

**Count parentheses**:

[Valid parenthesis](https://leetcode.com/problems/valid-parentheses/) | [My solution](count-parenthesis/valid-parentheses.js)

[Remove invalid parenthesis](https://leetcode.com/problems/remove-invalid-parentheses/) | [My solution](count-parenthesis/remove-invalid-parentheses.js)


**Binary search - K Closest elements**:

[Find k closest elements](https://leetcode.com/problems/find-k-closest-elements/) | [My solution](strings-and-binary-search/find-k-closest-elements.js)

**Binary search with non-exact conditions**:

https://leetcode.com/problems/peak-index-in-a-mountain-array/

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/

**Guess by binary search**:

https://www.interviewbit.com/problems/allocate-books/




```js
Strings & Binary Search
~Problems to get exposed to the topics:
https://leetcode.com/problems/binary-search/ 
https://www.interviewbit.com/problems/sorted-insert-position/
https://www.interviewbit.com/problems/search-for-a-range/
https://www.interviewbit.com/problems/square-root-of-integer/
https://www.interviewbit.com/problems/palindrome-string/
https://www.interviewbit.com/problems/longest-common-prefix/
https://www.interviewbit.com/problems/reverse-the-string/
https://www.interviewbit.com/problems/roman-to-integer/
https://www.interviewbit.com/problems/add-binary-strings/
https://www.interviewbit.com/problems/zigzag-string/

Pattern problems
Trie

https://leetcode.com/problems/implement-trie-prefix-tree/ 
https://www.interviewbit.com/problems/hotel-reviews/
https://www.interviewbit.com/problems/shortest-unique-prefix/ 

Count Parentheses
https://leetcode.com/problems/valid-parentheses/
https://leetcode.com/problems/remove-invalid-parentheses/

Binary search - K Closest elements
https://leetcode.com/problems/find-k-closest-elements/

Binary search with non-exact conditions
https://leetcode.com/problems/peak-index-in-a-mountain-array/ 
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/

Guess by binary search
https://www.interviewbit.com/problems/allocate-books/ 


class Trie {
  constructor() {
    this.root = {};
  }

  insert(word) {
    let node = this.root;
    for (let c of word) {
      if (node[c] == null) node[c] = {};
      node = node[c];
    }
    node.isWord = true;
  }

  traverse(word) {
    let node = this.root;
    for (let c of word) {
      node = node[c];
      if (node == null) return null;
    }
    return node;
  }
  
  search(word) {
    const node = this.traverse(word);
    return node != null && node.isWord === true;
  }

  startsWith(prefix) {
    return this.traverse(prefix) != null;
  }
}


Find shortest unique prefix to represent each word in the list.

NOTE : Assume that no word is prefix of another. In other words, the representation is always possible.

Example:

Input: [zebra, dog, duck, dove]
Output: {z, dog, du, dov}
where we can see that
zebra = z
dog = dog
duck = du
dove = dov


            d
          / | \
         o  u
        /\  |
       g  v c
          | |
          e k
          
          BFS (level by level)
          
class TrieNode {
  boolean isUnique = true;
  TrieNode[] next = new TrieNode[26];
}
public ArrayList<String> prefix(ArrayList<String> A) {
  TrieNode root = new TrieNode();
  for (String word : A) add(root, word);
  ArrayList<String> r = new ArrayList<>();
  for (String word : A) {
    StringBuilder s = new StringBuilder();
    TrieNode n = root;
    for (char c: word.toCharArray()) {
      n = n.next[c -'a'];
      s.append(c);
      if (n.isUnique) break;
    }
    r.add(s.toString());
  }
  return r;
}
private void add(TrieNode n, String word) {
  for (char c : word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) n.next[index] = new TrieNode();
    else n.next[index].isUnique = false;
    n = n.next[index];
  }
}

0: a
1: b
2: c
...



Given a set of reviews provided by the customers for different hotels and a string containing Good Words, you need to sort the reviews in descending order according to their Goodness Value (Higher goodness value first). We define the Goodness Value of a string as the number of Good Words in that string.

NOTE: Sorting should be stable. If review i and review j have the same Goodness Value then their original order would be preserved.

You are expected to use Trie in an Interview for such problems



Problem Constraints
1 <= No.of reviews <= 200
1 <= No. of words in a review <= 1000
1 <= Length of an individual review <= 10,000
1 <= Number of Good Words <= 10,000
1 <= Length of an individual Good Word <= 4
All the alphabets are lower case (a - z)


Input Format
First argument is a string A containing "Good Words" separated by "_" character

Second argument is a vector B of strings containing Hotel Reviews. Review strings are also separated by "_" character.



Output Format
Return a vector of integers which contain the original indexes of the reviews in the sorted order of reviews.



Example Input
Input 1:

 A = "cool_ice_wifi"
 B = ["water_is_cool", "cold_ice_drink", "cool_wifi_speed"]


Example Output
Output 1:

 [2, 0, 1]


Example Explanation
Explanation 1:

 sorted reviews are ["cool_wifi_speed", "water_is_cool", "cold_ice_drink"]
 
 
class TrieNode {
  boolean isLeaf = false;
  TrieNode[] next = new TrieNode[26];
}
public ArrayList<String> prefix(String A, ArrayList<String> B) {
  TrieNode root = new TrieNode();
  for (String word : A.split("_")) add(root, word); // cool_wifi_speed => A = ["cool", "wifi", "speed"]
  
  ArrayList<Integer> ratings = new ArrayList<>();
  for (String review : A) {
    int rating = 0;
    
    for (String word : review.split("_")) {
      if (search(root,word)) rating++;
    }
    ratings.add(rating);
  }
  ArrayList<Integer> r = new ArrayList<>();
  for (int i = 0; i < B.size(); i++) r.add(i);
  Collections.sort(r, (r1, r2)) -> {
    return ratings.get(r1) == ratings.get(r2) ? r1 - r2 : ratings.get(r2) - ratings.get(r1);
  });
  return r;
}
private void add(TrieNode n, String word) {
  for (char c : word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) n.next[index] = new TrieNode();
    n = n.next[index];
  }
  n.isLeaf = true;
}
private boolean search (TrieNode n, String word) {
  for (char c: word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) return false;
    n = n.next[index];
  }
  return n.isLeaf;
}




```

Strings & Binary Search
~Problems to get exposed to the topics:
https://leetcode.com/problems/binary-search/ 
https://www.interviewbit.com/problems/sorted-insert-position/
https://www.interviewbit.com/problems/search-for-a-range/
https://www.interviewbit.com/problems/square-root-of-integer/
https://www.interviewbit.com/problems/palindrome-string/
https://www.interviewbit.com/problems/longest-common-prefix/
https://www.interviewbit.com/problems/reverse-the-string/
https://www.interviewbit.com/problems/roman-to-integer/
https://www.interviewbit.com/problems/add-binary-strings/
https://www.interviewbit.com/problems/zigzag-string/

Pattern problems
Trie

https://leetcode.com/problems/implement-trie-prefix-tree/ 
https://www.interviewbit.com/problems/hotel-reviews/
https://www.interviewbit.com/problems/shortest-unique-prefix/ 

Count Parentheses
https://leetcode.com/problems/valid-parentheses/
https://leetcode.com/problems/remove-invalid-parentheses/

Binary search - K Closest elements
https://leetcode.com/problems/find-k-closest-elements/

Binary search with non-exact conditions
https://leetcode.com/problems/peak-index-in-a-mountain-array/ 
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/

Guess by binary search
https://www.interviewbit.com/problems/allocate-books/ 


class Trie {
  constructor() {
    this.root = {};
  }

  insert(word) {
    let node = this.root;
    for (let c of word) {
      if (node[c] == null) node[c] = {};
      node = node[c];
    }
    node.isWord = true;
  }

  traverse(word) {
    let node = this.root;
    for (let c of word) {
      node = node[c];
      if (node == null) return null;
    }
    return node;
  }
  
  search(word) {
    const node = this.traverse(word);
    return node != null && node.isWord === true;
  }

  startsWith(prefix) {
    return this.traverse(prefix) != null;
  }
}


Find shortest unique prefix to represent each word in the list.

NOTE : Assume that no word is prefix of another. In other words, the representation is always possible.

Example:

Input: [zebra, dog, duck, dove]
Output: {z, dog, du, dov}
where we can see that
zebra = z
dog = dog
duck = du
dove = dov


            d
          / | \
         o  u
        /\  |
       g  v c
          | |
          e k
          
          BFS (level by level)
          
class TrieNode {
  boolean isUnique = true;
  TrieNode[] next = new TrieNode[26];
}
public ArrayList<String> prefix(ArrayList<String> A) {
  TrieNode root = new TrieNode();
  for (String word : A) add(root, word);
  ArrayList<String> r = new ArrayList<>();
  for (String word : A) {
    StringBuilder s = new StringBuilder();
    TrieNode n = root;
    for (char c: word.toCharArray()) {
      n = n.next[c -'a'];
      s.append(c);
      if (n.isUnique) break;
    }
    r.add(s.toString());
  }
  return r;
}
private void add(TrieNode n, String word) {
  for (char c : word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) n.next[index] = new TrieNode();
    else n.next[index].isUnique = false;
    n = n.next[index];
  }
}

0: a
1: b
2: c
...



Given a set of reviews provided by the customers for different hotels and a string containing Good Words, you need to sort the reviews in descending order according to their Goodness Value (Higher goodness value first). We define the Goodness Value of a string as the number of Good Words in that string.

NOTE: Sorting should be stable. If review i and review j have the same Goodness Value then their original order would be preserved.

You are expected to use Trie in an Interview for such problems



Problem Constraints
1 <= No.of reviews <= 200
1 <= No. of words in a review <= 1000
1 <= Length of an individual review <= 10,000
1 <= Number of Good Words <= 10,000
1 <= Length of an individual Good Word <= 4
All the alphabets are lower case (a - z)


Input Format
First argument is a string A containing "Good Words" separated by "_" character

Second argument is a vector B of strings containing Hotel Reviews. Review strings are also separated by "_" character.



Output Format
Return a vector of integers which contain the original indexes of the reviews in the sorted order of reviews.



Example Input
Input 1:

 A = "cool_ice_wifi"
 B = ["water_is_cool", "cold_ice_drink", "cool_wifi_speed"]


Example Output
Output 1:

 [2, 0, 1]


Example Explanation
Explanation 1:

 sorted reviews are ["cool_wifi_speed", "water_is_cool", "cold_ice_drink"]
 
 
class TrieNode {
  boolean isLeaf = false;
  TrieNode[] next = new TrieNode[26];
}
public ArrayList<String> prefix(String A, ArrayList<String> B) {
  TrieNode root = new TrieNode();
  for (String word : A.split("_")) add(root, word); // cool_wifi_speed => A = ["cool", "wifi", "speed"]
  
  ArrayList<Integer> ratings = new ArrayList<>();
  for (String review : A) {
    int rating = 0;
    
    for (String word : review.split("_")) {
      if (search(root,word)) rating++;
    }
    ratings.add(rating);
  }
  ArrayList<Integer> r = new ArrayList<>();
  for (int i = 0; i < B.size(); i++) r.add(i);
  Collections.sort(r, (r1, r2)) -> {
    return ratings.get(r1) == ratings.get(r2) ? r1 - r2 : ratings.get(r2) - ratings.get(r1);
  });
  return r;
}
private void add(TrieNode n, String word) {
  for (char c : word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) n.next[index] = new TrieNode();
    n = n.next[index];
  }
  n.isLeaf = true;
}
private boolean search (TrieNode n, String word) {
  for (char c: word.toCharArray()) {
    int index = c - 'a';
    if (n.next[index] == null) return false;
    n = n.next[index];
  }
  return n.isLeaf;
}

https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321

chap 1, 2 (no sql vs sql), 3, 5-9 (super important!!!), 10-11 (important), 12 (skim thru)

Content Serving: videos, photos, music, live videos, disappearing content etc.
Search: Information Retrieval, Learning to Rank
Messaging & Notification
Social Networks: Feeds (serving, ranking, etc.), relationships, etc.
Distributed storages: Distributed file system, key-value, databases
Data Processing systems and Data Warehouses
Content recommendations and Leaderboard: Netflix movie recommendations, Top Spotify songs, Top Youtube videos, etc.

template for the next session



